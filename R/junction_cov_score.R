#' Score coverage disruptions
#'
#' \code{junction_cov_score} will score disruptions in the coverage across the
#' intronic/exonic regions associated with each junction. This abnormality score
#' is generated by \code{score_func} and operates by comparing coverage
#' originating from patients to a set of controls. Then, for each junction it
#' obtains the score of the region with the highest absolute score/greatest
#' disruption.
#'
#' @inheritParams junction_annot
#' @inheritParams junction_score
#'
#' @param cov list containing normalised coverage data that is outputted from
#'   \link{junction_cov_norm}.
#'
#' @return junctions as a
#'   \code{\link[SummarizedExperiment]{SummarizedExperiment}} object with
#'   additional assays named \code{cov_region} and \code{cov_score}.
#'   \code{cov_region} labels the region of greatest disruption (1 = exon_start,
#'   2 = exon_end, 3 = intron) and \code{cov_score} contains the scores of the
#'   region with the greatest disruption.
#'
#' @examples
#'
#' \dontrun{
#' # leave this as not run for now to save time for R CMD check
#' ref <- "ftp://ftp.ensembl.org/pub/release-100/gtf/homo_sapiens/Homo_sapiens.GRCh38.100.gtf.gz"
#' ref <- GenomicFeatures::makeTxDbFromGFF(ref)
#' junctions <- junction_norm(junctions_annot_example)
#' junctions <- junction_score(junctions)
#' cov_paths_case <- list.files("/data/RNA_seq_diag/mito/bw/", full.names = T)[1:2]
#' cov_paths_control <- list.files("/data/recount/GTEx_SRP012682/gtex_bigWigs/all_gtex_tissues_raw_bigWigs/", full.names = T)[1:2]
#' cov <- junction_cov_norm(junctions, ref, unannot_width = 20, cov_paths_case, cov_paths_control, cov_chr_control = "chr")
#'
#' junctions
#' }
#'
#' @export
junction_cov_score <- function(junctions, cov, score_func = .zscore, ...) {

    ##### Check user input is correct #####

    if (!identical(names(cov), c("case", "control"))) {
        stop("cov should have the names 'case' and 'control'")
    }

    if (!identical(names(cov[["case"]]), c("exon_cov_start", "exon_cov_end", "intron_cov")) |
        !identical(names(cov[["control"]]), c("exon_cov_start", "exon_cov_end", "intron_cov"))) {
        stop("coverage matrices should be named 'exon_cov_start', 'exon_cov_end', 'intron_cov'")
    }

    ##### Score coverage in relation to controls #####

    print(stringr::str_c(Sys.time(), " - Generating coverage abnormality score..."))

    cov_scores <- .cov_score(cov, score_func, ...)

    ##### Obtain regions of greatest coverage dysruption #####

    print(stringr::str_c(Sys.time(), " - Obtaining regions with greatest coverage dysruption..."))

    cov_region_scores_max <- .cov_score_max(cov_scores)

    ##### Store output #####

    names(cov_region_scores_max[["regions"]]) <- dimnames(junctions)[[2]]
    names(cov_region_scores_max[["scores"]]) <- dimnames(junctions)[[2]]
    assays(junctions)[["cov_region"]] <- cov_region_scores_max[["regions"]]
    assays(junctions)[["cov_score"]] <- cov_region_scores_max[["scores"]]

    print(stringr::str_c(Sys.time(), " - done!"))

    return(junctions)
}

#' Score coverage disruptions
#'
#' \code{.cov_score}
#'
#' @inheritParams junction_cov_score
#' @inheritParams junction_score
#'
#' @return
#'
#' @keywords internal
#' @noRd
.cov_score <- function(cov, score_func, ...) {
    cov_scores <- vector(mode = "list", length = length(cov[["case"]]))

    for (region in c("exon_cov_start", "exon_cov_end", "intron_cov")) {
        cov_score_mat <- matrix(
            ncol = ncol(cov[["case"]][[region]]),
            nrow = nrow(cov[["case"]][[region]])
        )

        for (i in 1:nrow(cov_score_mat)) {
            cov_score_mat[i, ] <-
                score_func(
                    x = cov[["case"]][[region]][i, ],
                    y = cov[["control"]][[region]][i, ],
                    ...
                )
        }

        cov_scores[[stringr::str_replace(region, "cov", "cov_score")]] <- cov_score_mat
    }

    return(cov_scores)
}

#' Obtain region of highest coverage disruption for each junction
#'
#' \code{.cov_score}
#'
#' @inheritParams junction_cov_score
#' @inheritParams junction_score
#'
#' @return
#'
#' @keywords internal
#' @noRd
.cov_score_max <- function(cov_scores) {
    region_names <- c("exon_cov_score_start", "exon_cov_score_end", "intron_cov_score")

    cov_scores_max <- matrix(
        ncol = ncol(cov_scores[[1]]),
        nrow = nrow(cov_scores[[1]])
    )

    cov_region_max <- matrix(
        ncol = ncol(cov_scores[[1]]),
        nrow = nrow(cov_scores[[1]])
    )

    # loop across samples
    for (i in 1:ncol(cov_scores[["exon_cov_score_start"]])) {

        ##### Obtain the most dysregulated region #####

        cov_scores_per_samp <-
            dplyr::tibble(
                exon_cov_score_start = cov_scores[["exon_cov_score_start"]][, i],
                exon_cov_score_end = cov_scores[["exon_cov_score_end"]][, i],
                intron_cov_score = cov_scores[["intron_cov_score"]][, i]
            )

        # find index of the region with highest absolute score
        cov_region_max[, i] <- cov_scores_per_samp %>%
            apply(
                MARGIN = 1,
                FUN = function(x) {
                    which.max(abs(x))
                }
            )

        cov_scores_max[, i] <- cov_scores_per_samp %>%
            apply(
                MARGIN = 1,
                FUN = function(x) {
                    x[which.max(abs(x))]
                }
            )
    }

    cov_region_scores_max <- list(
        regions = cov_region_max,
        scores = cov_scores_max
    )

    return(cov_region_scores_max)
}
