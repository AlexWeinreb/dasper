% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coverage_norm.R
\name{coverage_norm}
\alias{coverage_norm}
\title{Load and normalise coverage from RNA-sequencing data}
\usage{
coverage_norm(
  junctions,
  ref,
  unannot_width = 20,
  coverage_paths_case,
  coverage_paths_control,
  coverage_chr_control = NULL,
  load_func = .coverage_load,
  bp_param = BiocParallel::SerialParam(),
  norm_const = 1
)
}
\arguments{
\item{junctions}{junction data as a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{RangedSummarizedExperiment-class}
object.}

\item{ref}{either path to gtf/gff3 or object of class \link[GenomicFeatures:TxDb-class]{TxDb-class}.}

\item{unannot_width}{integer scalar determining the width of the region to
obtain coverage from when the end of of a junction does not overlap an
existing exon.}

\item{coverage_paths_case}{paths to the BigWig files containing the
coverage of your case samples. Must be the same length and order to the
samples in \code{junctions}.}

\item{coverage_paths_control}{paths to the BigWig files}

\item{coverage_chr_control}{either "chr" or "no_chr", indicating the
chromosome format of control coverage data. Only used if you know the
chromosome format of the control BigWig files is different to that of
your junctions.}

\item{load_func}{a function to use to load coverage. Currently only for
internal use to increase testing speed.}

\item{bp_param}{a
\link[BiocParallel:BiocParallelParam-class]{BiocParallelParam-class} instance
denoting whether to parallelise the loading of coverage across BigWig files.}

\item{norm_const}{numeric scaler to add to the normalisation coverage to avoid dividing
by 0s and resulting NaN or Inf values.}
}
\value{
list containing two sublists, one for cases and the other controls. Each
sublist contains 3 matrices, corresponding the coverage for each sample
across the 2 exons and intron associated with every junction.
}
\description{
\code{coverage_norm} obtains regions of interest for each junction where coverage
disruptions would be expected. These consist of the intron itself the
overlapping exon definitions (if ends of junctions are annotated), picking
the shortest exon when multiple overlap one end. If ends are unannotated,
\code{coverage_norm} will use a user-defined width set by \code{unannot_width}. Then,
coverage will be loaded using
\href{https://github.com/ChristopherWilks/megadepth}{megadepth} and
normalised to a set region per junction.  By default, the boundaries of each
gene associated to a junction are used as the region to normalise to.
}
\examples{

if (!exists("ref")) {
    # use Genomic state to load txdb (GENCODE v31)
    ref <- GenomicState::GenomicStateHub(version = "31", genome = "hg38", filetype = "TxDb")[[1]]
    # convert seqlevels to match junctions
    seqlevels(ref) <- stringr::str_replace(seqlevels(ref), "chr", "")
}

if (!exists("junctions_processed")) {
    junctions_processed <-
        junction_process(
            junctions_example,
            ref,
            count_thresh = c("raw" = 5),
            n_samp = c("raw" = 1),
            width_range = c(25, 1000000),
            types = c("ambig_gene", "unannotated"),
        )
    GenomeInfoDb::seqlevels(junctions_processed) <-
        paste0("chr", GenomeInfoDb::seqlevels(junctions_processed))
}

# obtain path to example bw on recount2
url <- recount::download_study(
    project = "SRP012682",
    type = "samples",
    download = FALSE
)

bw_path <- dasper:::.file_cache(url[1])

if (!exists("coverage_normed")) {
    coverage_normed <- coverage_norm(
        junctions_processed,
        ref,
        unannot_width = 20,
        coverage_paths_case = rep(bw_path, 2),
        coverage_paths_control = rep(bw_path, 2),
        coverage_chr_control = "chr"
    )
}
}
\seealso{
Coverage processing functions
\code{\link{coverage_process}()},
\code{\link{coverage_score}()}
}
\concept{coverage}
