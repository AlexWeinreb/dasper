% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outlier_process.R
\name{outlier_process}
\alias{outlier_process}
\title{Wrapper for processing outliers}
\usage{
outlier_process(
  junctions,
  feature_names = c("score", "coverage_score"),
  samp_id_col = "samp_id",
  bp_param = BiocParallel::SerialParam(),
  ...
)
}
\arguments{
\item{junctions}{junction data as a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{RangedSummarizedExperiment-class}
object.}

\item{feature_names}{names of assays in \code{junctions} that are to be used as
input into the outlier detection model.}

\item{samp_id_col}{name of the column in the
\link[SummarizedExperiment:SummarizedExperiment-class]{SummarizedExperiment}
that details the sample ids.}

\item{bp_param}{a
\link[BiocParallel:BiocParallelParam-class]{BiocParallelParam-class} instance
denoting whether to parallelise the calculating of outlier scores across
samples.}

\item{...}{additional arguments passed to the outlier detection model
(isolation forest) for setting parameters.}
}
\value{
\code{DataFrame} with one row per cluster detailing each cluster's
associated junctions, outlier scores, ranks and genes.
}
\description{
\code{outlier_process} wraps all "outlier_" prefixed functions in
\link{dasper}. This is designed to simplify processing of the detecting
outlier junctions for those familiar or uninterested with the intermediates.
}
\examples{

if (.Platform$OS.type != "windows") {
    # tell reticulate to use the python3 install
    # if windows skip this step
    reticulate::use_python(Sys.which("python3"), required = TRUE)
}

if (!exists("ref")) {
    # use Genomic state to load txdb (GENCODE v31)
    ref <- GenomicState::GenomicStateHub(version = "31", genome = "hg38", filetype = "TxDb")[[1]]
    # convert seqlevels to match junctions
    seqlevels(ref) <- stringr::str_replace(seqlevels(ref), "chr", "")
}

if (!exists("junctions_processed")) {
    junctions_processed <-
        junction_process(
            junctions_example,
            ref,
            count_thresh = c("raw" = 5),
            n_samp = c("raw" = 1),
            width_range = c(25, 1000000),
            types = c("ambig_gene", "unannotated"),
        )
    GenomeInfoDb::seqlevels(junctions_processed) <-
        paste0("chr", GenomeInfoDb::seqlevels(junctions_processed))
}

# obtain path to example bw on recount2
url <- recount::download_study(
    project = "SRP012682",
    type = "samples",
    download = FALSE
)

bw_path <- dasper:::.file_cache(url[1])

if (!exists("junctions_w_coverage")) {
    junctions_w_coverage <-
        coverage_process(
            junctions_processed,
            ref,
            coverage_paths_case = rep(bw_path, 2),
            coverage_paths_control = rep(bw_path, 3)
        )
}

outlier_process(junctions_w_coverage)
}
\seealso{
Outlier processing functions
\code{\link{outlier_aggregate}()},
\code{\link{outlier_detect}()}
}
\concept{outlier}
