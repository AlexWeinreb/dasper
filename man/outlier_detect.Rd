% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outlier_detect.R
\name{outlier_detect}
\alias{outlier_detect}
\title{Detecting outlier junctions}
\usage{
outlier_detect(
  junctions,
  feature_names = c("score", "coverage_score"),
  bp_param = BiocParallel::SerialParam(),
  ...
)
}
\arguments{
\item{junctions}{junction data as a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{RangedSummarizedExperiment-class}
object.}

\item{feature_names}{names of assays in \code{junctions} that are to be used as
input into the outlier detection model.}

\item{bp_param}{a
\link[BiocParallel:BiocParallelParam-class]{BiocParallelParam-class} instance
denoting whether to parallelise the calculating of outlier scores across
samples.}

\item{...}{additional arguments passed to the outlier detection model
(isolation forest) for setting parameters.}
}
\value{
junctions as a
\link[SummarizedExperiment:RangedSummarizedExperiment-class]{RangedSummarizedExperiment-class}
object with additional assays named \code{outlier_score}. The lower the outlier
score, the more of an outlier a junction is observed to be.
}
\description{
\code{outlier_detect} will use the features in
\link[SummarizedExperiment:SummarizedExperiment-class]{assays} named
\code{feature_names} as input into an unsupervised outlier detection algorithm to
score each junction based on how outlier-y it looks in relation to other
junctions in the patient. The default expected \code{score} and \code{coverage_score}
features can be calculated using the \link{junction_process} and
\link{coverage_process} respectively.
}
\examples{

if (.Platform$OS.type != "windows") {

    # tell reticulate to use the python3 install
    # if windows skip this step
    reticulate::use_python(Sys.which("python3"), required = TRUE)
}

if (!exists("ref")) {
    ref <- "ftp://ftp.ensembl.org/pub/release-100/gtf/homo_sapiens/Homo_sapiens.GRCh38.100.gtf.gz"
    ref <- GenomicFeatures::makeTxDbFromGFF(ref)
}

if (!exists("junctions_processed")) {
    junctions_processed <-
        junction_process(
            junctions_example,
            ref,
            count_thresh = c("raw" = 5),
            n_samp = c("raw" = 1),
            width_range = c(25, 1000000),
            types = c("ambig_gene", "unannotated"),
        )
    GenomeInfoDb::seqlevels(junctions_processed) <-
        paste0("chr", GenomeInfoDb::seqlevels(junctions_processed))
}

url <- recount::download_study(
    project = "SRP012682",
    type = "samples",
    download = FALSE
)
bw_path <- file.path(tempdir(), basename(url[1]))

if (!file.exists(bw_path)) {
    download.file(url[1], bw_path)
}

if (!exists("junctions_w_coverage")) {
    junctions_w_coverage <-
        coverage_process(
            junctions_processed,
            ref,
            coverage_paths_case = rep(bw_path, 2),
            coverage_paths_control = rep(bw_path, 3)
        )
}

if (!exists("junctions_w_outliers")) {
    junctions_w_outliers <- outlier_detect(junctions_w_coverage)
}

junctions_w_outliers
}
\seealso{
for more details on the isolation forest model used:
https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.IsolationForest.html

Outlier processing functions
\code{\link{outlier_aggregate}()},
\code{\link{outlier_process}()}
}
\concept{outlier}
